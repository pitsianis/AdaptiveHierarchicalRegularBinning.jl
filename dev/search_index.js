var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = AdaptiveHierarchicalRegularBinning","category":"page"},{"location":"#AdaptiveHierarchicalRegularBinning","page":"Home","title":"AdaptiveHierarchicalRegularBinning","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AdaptiveHierarchicalRegularBinning.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [AdaptiveHierarchicalRegularBinning]","category":"page"},{"location":"#AdaptiveHierarchicalRegularBinning.bit_interleave-Tuple{AbstractMatrix{<:Unsigned}}","page":"Home","title":"AdaptiveHierarchicalRegularBinning.bit_interleave","text":"bit_interleave(W[; dims])\n\nInterleaves all unsigned integers along a dimention.\n\nArguments\n\nW: The matrix\ndims: The dimention. Defaults to 1\n\n\n\n\n\n","category":"method"},{"location":"#AdaptiveHierarchicalRegularBinning.bit_interleave-Tuple{Type{<:AdaptiveHierarchicalRegularBinning.InterleaveMethod}, AbstractVector{<:Unsigned}}","page":"Home","title":"AdaptiveHierarchicalRegularBinning.bit_interleave","text":"bit_interleave([M, ]W)\n\nInterleaves an array of unsigned integers.\n\nArguments\n\nM: The method with which to interleave\nW: The array\n\nExamples\n\njulia> bit_interleave([0x00FF, 0x000F]) |> bitstring\n\"0101010111111111\"\n\njulia> bit_interleave([0x000F, 0x00FF]) |> bitstring\n\"1010101011111111\"\n\njulia> bit_interleave([0x0080, 0x0001]) |> bitstring\n\"0100000000000010\"\n\njulia> bit_interleave([0x0001, 0x0080]) |> bitstring\n\"1000000000000001\"\n\n\n\n\n\n","category":"method"},{"location":"#AdaptiveHierarchicalRegularBinning.bit_interleave-Union{Tuple{Vararg{T}}, Tuple{T}} where T<:Unsigned","page":"Home","title":"AdaptiveHierarchicalRegularBinning.bit_interleave","text":"bit_interleave(Ws)\n\n\nInterleaves all unsigned integers.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptiveHierarchicalRegularBinning.bit_space-Tuple{Type{<:AdaptiveHierarchicalRegularBinning.InterleaveMethod}, Unsigned, Integer}","page":"Home","title":"AdaptiveHierarchicalRegularBinning.bit_space","text":"bit_space(M, w, n)\n\nEvenly space out bits.\n\nArguments\n\nM: The method to space out the bits\nw: The word to space out\nn: The amount of padding\n\nExamples\n\njulia> bit_space(Brute, 0x00ABCDEF, 0) |> bitstring\n\"00000000101010111100110111101111\"\n\njulia> bit_space(Brute, 0x00ABCDEF, 1) |> bitstring\n\"10100000101000101010100010101010\"\n\njulia> bit_space(Brute, 0x00ABCDEF, 2) |> bitstring\n\"00000100100100100000100100100100\"\n\njulia> bit_space(Brute, 0x00ABCDEF, 3) |> bitstring\n\"10001000100000001000100010001000\"\n\njulia> bit_space(Pdep, 0x00ABCDEF, 2) == bit_space(Brute, 0x00ABCDEF, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#AdaptiveHierarchicalRegularBinning.bit_space_mask-Tuple{Type{<:Unsigned}, Integer}","page":"Home","title":"AdaptiveHierarchicalRegularBinning.bit_space_mask","text":"bit_space_mask(_, _)\n\n\nGenerates a spaced mask.\n\nArguments\n\nT: The resulting type\nn: The amount of padding\n\nExamples\n\njulia> bit_space_mask(UInt8, 0) |> bitstring\n\"11111111\"\n\njulia> bit_space_mask(UInt8, 1) |> bitstring\n\"01010101\"\n\njulia> bit_space_mask(UInt8, 2) |> bitstring\n\"01001001\"\n\njulia> bit_space_mask(UInt8, 3) |> bitstring\n\"00010001\"\n\n\n\n\n\n","category":"method"},{"location":"#AdaptiveHierarchicalRegularBinning.countsortperm!-Tuple{Any, Any, Any}","page":"Home","title":"AdaptiveHierarchicalRegularBinning.countsortperm!","text":"countsortperm!(p, v, C)\n\n\nSequential count sort permutation. Overwrite vector p with the permutation that puts vector of values v[p] in non decreasing order.\n\np: preallocated output vector of integers to receive the permutation\nv: input vector of integer values that determine order. The unique values      of v must be in the range 0:m where m << length(v)\nC: preallocated workspace of size at least m+1\n\n\n\n\n\n","category":"method"},{"location":"#AdaptiveHierarchicalRegularBinning.morton-Tuple{Any, Any}","page":"Home","title":"AdaptiveHierarchicalRegularBinning.morton","text":"morton(p, L) -> Any\n\n\nSpatially encode a single point 0 ≤ p < 1 for L levels\n\n\n\n\n\n","category":"method"},{"location":"#AdaptiveHierarchicalRegularBinning.pcountsortperm!-Tuple{Vector{Int64}, Vector{Int64}, Matrix{Int64}}","page":"Home","title":"AdaptiveHierarchicalRegularBinning.pcountsortperm!","text":"pcountsortperm!(p::Vector{Int64}, v::Vector{Int64}, C::Matrix{Int64})\n\n\nMultithreaded count sort permutation. Overwrite vector p with the permutation that puts vector of values v[p] in non decreasing order.\n\np: preallocated output vector of integers to receive the permutation\nv: input vector of integer values that determine order. The unique values      of v must be in the range 0:m where m << length(v)\nC: preallocated workspace of size at least (m+1+8:np+1),      where np is the number of threads.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptiveHierarchicalRegularBinning.spatial_encode-Tuple{Any, Any}","page":"Home","title":"AdaptiveHierarchicalRegularBinning.spatial_encode","text":"spatial_encode(x, L; dims) -> Tuple{Any, Any, Any}\n\n\nSpatially encode the point cloud coordinates x for L levels   dims denotes the dimension that contains the coordinates of a single point.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptiveHierarchicalRegularBinning.translate_scale_vals-Tuple{Any}","page":"Home","title":"AdaptiveHierarchicalRegularBinning.translate_scale_vals","text":"translate_scale_vals(p; center, dims) -> Tuple{Any, Any}\n\n\nFind the displacement vector δ and scale scalar σ parameters that will transform the cloud points p to be within a unit box [0,1),\n\n0 ≤ σ (p - δ) < 1\n\np: cloud point coordinates\ncenter: flag to center the cloud by dividing the slack evenly, default false\ndims  : dimension of p expressing single point coordinates,\n\ni.e. if the i^th point is p[i,:], then set dims=2.\n\n\n\n\n\n","category":"method"}]
}
